# MinIO tenant with cert-manager [![Slack](https://slack.min.io/slack?type=svg)](https://slack.min.io)

This document explains how to deploy a MinIO tenant using certificates generated by [cert-manager](https://cert-manager.io/) 
using a self-signed issuer.

On A Kubernetes cluster, Certificate Manager requires at a global level a `Cluster Issuer` to generated intermediary Issuers
and certificates. 

At namespace level Cert Manager issues certificates derivative of a `Issuer`.

The main difference between a `Cluster Issuer` and a `Issuer` is that `Cluster Issuer` can Issue certificates for several namespaces, meanwhile a `Issuer` can only issue in a single namespace.

To learn more about Cert Manager Issuers refer to their documentation https://cert-manager.io/docs/concepts/issuer/.

Take for example this logical view of a Kubernetes cluster below:

![Cert-manager-namespaces.png](images%2FCert-manager-namespaces.png)

In the cluster exists 4 namespaces:
minio-operator, tenant-1, tenant-2, other-namespace, each one contains pods and services, in this environment we need Cert Manager
to be able to issue certificates and the different services and pods to trust each others certificates, 
for that we are going to create a global root issuer, and an intermediary issuer in each tenant namespace:

![Cert-manager Issuers.png](images%2FCert-manager%20Issuers.png)

Cert Manager is installed in the `cert-namanger` namespace, as per the Root Issuer, it is created in the default namespace,
For each namespace we create, we will create a local Issuer, as well for the minio-operator namespace. 


> [!NOTE]  
> Self-signed Cluster Issuer is going to be the example shown in this guide, however the [other Issuers supported by Cert Manager](https://cert-manager.io/docs/configuration/issuers/) can also be used,
> the main difference is that you will provide the `Issuer` CA certificate to minio, instead of the `root` CA mentioned in the guide.

## Getting Started

### Prerequisites

- Kubernetes version `+v1.21`. While cert-manager
  supports [earlier K8s versions](https://cert-manager.io/docs/installation/supported-releases/), the MinIO Operator
  requires 1.21 or later.
- MinIO Operator installed
- [kustomize](https://kustomize.io/) installed
- `kubectl` access to your `k8s` cluster
- [cert-manager](https://cert-manager.io/docs/releases/release-notes/release-notes-1.12/) 1.12.X (preferred) or later installed.

## Setup Cert-manager

```bash
kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.12.9/cert-manager.yaml
```

### Create Cluster Self-signed root Issuer
The root Issuer will be the root level on certificate from which all other certificates will derivate from, 
let's ask to Cert Manager to generate it by creating a `ClusterIssuer` resource:

```yaml
# selfsigned-root-clusterissuer.yaml
apiVersion: cert-manager.io/v1
kind: ClusterIssuer
metadata:
  name: selfsigned-root
spec:
  selfSigned: {}
```

```shell
kubectl apply -f selfsigned-root-clusterissuer.yaml
```

### Create tenant-1 namespace CA intermediary Issuer and
In this step we will create the Intermediary Certificate Authority (CA) certificate used to issue certificates for MinIO.

First let's create the `Issuer`:

```yaml
# tenant-1-ca-issuer.yaml
apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: tenant-1-ca-issuer
  namespace: tenant-1
spec:
  ca:
    secretName: tenant-1-ca-secret
```

```shell
kubectl apply -f tenant-1-ca-issuer.yaml
```

Now we are going to request a Certificate with the `isCA: true` spec, this will be our intermediary CA.

```yaml
# tenant-1-ca-certificate.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: tenant-1-ca-certificate
  namespace: tenant-1
spec:
  isCA: true
  commonName: tenant-1-ca
  secretName: tenant-1-ca-secret
  duration: 70128h # 8y
  privateKey:
    algorithm: ECDSA
    size: 256
  issuerRef:
    name: selfsigned-root
    kind: ClusterIssuer
    group: cert-manager.io
```

```shell
kubectl apply -f tenant-1-ca-certificate.yaml
```

## Deploy tenant 

### Create certificate for Tenant

We need to request `cert-manager` to issue a new certificate based on the following internal domains.

```shell
minio.<namespace>
minio.<namespace>.svc
minio.<namespace>.svc.<cluster domain>
*.<tenant-name>-hl.<namespace>.svc.<cluster domain>
*.<namespace>.svc.<cluster domain>
```

> [!IMPORTANT]
> Replace `<tenant-name>`, `<namespace>` and `<cluster domain>` with the actual values for your MinIO tenant, Please note the 3 key element names:
> * `tenant-name` is the name provided to your tenant this is the one provided in the `metadata.name` of the Tenant YAML, for this example it will be `myminio`.
> * `namespace` is the namespace where the tenant is created, the `metadata.namespace` notes that in the Tenant YAML, for this example it will be `tenant-1`.
> * `cluster domain` is the DNS assigned in your kubernetes cluster, typically it is `cluster.local`, check on your coredns configuration for the right one assigned to your kubernetes cluster.
> For example querying `kubectl get configmap coredns -n kube-system -oyaml | yq ".data"`, this command could vary depending on the Kubernetes distribution like Openshift, Rancher, EKS, etc.

Create a `Certificate` for the domains mentioned above:

```yaml
# tenant-1-minio-certificate.yaml
apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: tenant-certmanager-cert
  namespace: tenant-1
spec:
  dnsNames:
    - "minio.tenant-1"
    - "minio.tenant-1.svc"
    - '*.minio-tenant-1.svc.cluster.local'
    - '*.minio.tenant-1.svc.cluster.local'
    - '*.myminio-hl.tenant-1.svc.cluster.local'
  secretName: tenant-certmanager-tls
  issuerRef:
    name: tenant-certmanager-issuer
```

```shell
kubectl apply -f tenant-1-minio-certificate.yaml
```

### Setup tenant to use certificate created by cert-manager 

In the tenant spec make sure to do the following steps:

* Disable `spec.requestAutoCert` as this will instruct Operator to do not attempt to issue certificates and instead rely on Cert Manager to provide them on secrets.
* Reference the Secret containing the TLS certificate we just issued in the previous step in `spec.externalCertSecret`.

Here is an example of Tenant sections should look like:

```yaml
apiVersion: minio.min.io/v2
kind: Tenant
metadata:
  name: myminio
  namespace: tenant-1
spec:
  ## Disable default tls certificates.
  requestAutoCert: false
  ## Use certificates generated by cert-manager.
  externalCertSecret:
    - name: tenant-certmanager-tls
      type: cert-manager.io/v1
```

## Trust CA in MinIO Operator

MinIO Operator can trust as many CA certificates as provided, just create a secret with the prefix `operator-ca-tls-` 
followed by an identifier in the `minio-operator` namespace, in this example the secret name will be `operator-ca-tls-tenant-1`.

MinIO Operator is going to mount and trust all certificates issued by the provided CA's. This is specifically needed because
Operator performs health checks from MinIO in the health cluster endpoint (see more in docs https://min.io/docs/minio/kubernetes/upstream/operations/monitoring/healthcheck-probe.html#cluster-write-quorum).

Missing to instruct Operator to trust the MinIO Certificate (or it's CA) will cause an error log message in the Operator Pod logs as following:

```error
Failed to get cluster health: Get "https://minio.tenant-1.svc.cluster.local/minio/health/cluster":
x509: certificate signed by unknown authority
```

### Create `operator-ca-tls-tenant-1` secret

Copy the cert-manager generated CA certificate into the minio-operator namespace, this will allow Operator to trust the cert-manager issued CA and it's derivatives.

Get the CA into a `ca.crt` file in the filesystem.
```sh
kubectl get secrets -n tenant-1 tenant-1-ca-tls -o=jsonpath='{.data.ca\.crt}' | base64 -d > ca.crt
```

Create the secret

```sh
kubectl create secret generic operator-ca-tls-tenant1 --from-file=ca.crt -n minio-operator
```

Restart the minio-operator

```sh
kubectl rollout restart deployment.apps/minio-operator -n minio-operator
```



